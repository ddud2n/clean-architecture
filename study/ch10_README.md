# 10. 아키텍처 경계 강제하기

> 일정 규모 이상의 모든 프로젝트에서는
> 계층 간의 경계가 약화되고, 코드는 점점 더 테스트하기 어려워지고, 새로운 기능을 구현하는 데 점점 더 많은 시간이 든다. <br>
> 아키텍처 내의 경계를 강제하는 방법과 함께 아키텍처 붕괴에 맞서 싸우기 위해 취할 수 있는 몇 가지 조치를 살펴보자.
>

## 경계와 의존성

![image](https://user-images.githubusercontent.com/16996054/159099232-0e21d2ba-df6d-4c6b-b4b3-b3d1a0f634be.png)

<br>

## 접근 제한자

> package-private 제한자는 중요하다.

자바 패키지를 통해 클래스들을 응집적인 '모듈'로 만들어 주기 때문이다.

이러한 모듈 내에 있는 클래스들은 서로 접근 가능하지만, 패키지 바깥에서는 접근할 수 없다.
그럼 모듈의 진입점으로 활용될 클래스들만 골라서 public으로 만들면 된다.
이렇게 하면 의존성이 잘못된 방향을 가리켜서 의존성 규칙을 위반할 위험이 줄어든다.

package-private 제한자는 몇 개 정도의 클래스로만 이뤄진 작은 모듈에서 가장 효과적이다.

그러나 패키지 내의 클래스가 특정 개수를 넘어가기 시작하면 하나의 패키지에 너무 많은 클래스를 포함하는 것이 혼란스러워지게 된다.
이렇게 되면 코드를 쉽게 찾을 수 있도록 하위 패키지를 만드는 방법을 선호한다.
하지만 이렇게 하면 자바는 하위 패키지를 다른 패키지로 취급하기 때문에 package-private 맴버에 접근할 수 없어 public으로 만들어 노출시켜야 하기 때문에 아키텍처에서 의존성 규칙이 깨질 수 있는
환경이 만들어진다.


<br>

## 컴파일 후 체크

클래스에 public 제한자를 쓰면 아키텍처 상의 의존성 방향이 잘못되더라도 컴파일러는 다른 클래스들이 이 클래스를 사용하도록 허용한다.
이런 경우에는 컴파일러가 전혀 도움이 되지 않기 때문에 의존성 규칙을 위반했는지 확인할 다른 수단을 찾아야 한다.

> 한 가지 방법은 컴파일 후 체크를 도입하는 것이다.

다시 말해, 코드가 컴파일된 후에 런타임에 체크한다는 것이다. 이런 런타임 체크는 지속적인 통합 빌드 환경에서 자동화된 테스트 과정에서 가장 잘 동작한다.

이러한 체크를 도와주는 자바용 도구로 `ArchUnit`이 있다. ArchUnit은 의존성 방향이 기대한 대로 잘 설정돼 있는지 체크할 수 있는 API를 제공한다. 의존성 규칙 위반을 발견하면 예외를 던진다.

<br>

## 빌드 아티펙트

지금까지 코드 상에서 아키텍처 경계를 구분하는 유일한 도구는 패키지였다. 모든 코드가 같은 모놀리식 빌드 아티팩트의 일부였던 셈이다.

빌드 아티팩트란, 자동화된 빌드 프로세스의 결과물이다. (`Maven`, `Gradle`) 즉, JAR 파일

![image](https://user-images.githubusercontent.com/16996054/159099995-a26116ed-6df1-449f-a7a0-e0ecd524fd6b.png)

빌드 도구의 주요한 기능 중 하나는 의존성 해결이다.
어떤 코드베이스를 빌드 아티팩트로 변환하기 위해 빌드 도구가 가장 먼저 할 일은 코드베이스가 의존하고 있는 모든 아티팩트가 사용 가능한지 확인하는 것이다.
만약 사용 불가능한 것이 있다면 아티팩트 리포지토리로부터 가져오려고 시도한다. 이마저도 실패하면 에러와 함께 빌드가 실패한다.

이를 활용해 모듈과 아키텍처의 계층 간의 의존성을 강제할 수 있다.
각 모듈 혹은 계층에 대해 전용 코드베이스와 빌드 아티팩트로 분리된 빌드 모듈(JAR 파일)을 만들 수 있다.

> 각 모듈의 빌드 스크립트에서는 아키텍처에서 허용하는 의존성만 지정한다.

- 장점
    - 모듈간 의존성을 더 잘 제어할 수 있다
    - 순환 의존성을 허용하지 않는다
    - 특정 모듈의 코드를 격리한 채로 변경할 수 있다 (모듈간 부리되어 있기 때문)
    - 의존성이 스크립트에 명시적으로 선언되어 있다 (의식적인 행동)

- 단점
    - 빌드 스크립트의 유지보수 비용 (빌드모듈 나누기 전에 아키텍처가 어느 정도 안정된 상태로 만든다)
    - 모듈간 매핑을 더 많이 수행해야 한다 (그만큼 한 모듈에 대한 의존성이 줄어든다는 장점도 있다) 
